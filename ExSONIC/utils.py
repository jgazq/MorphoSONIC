# -*- coding: utf-8 -*-
# @Author: Theo Lemaire
# @Date:   2018-08-27 14:38:30
# @Last Modified by:   Theo Lemaire
# @Last Modified time: 2019-01-17 14:47:20

import os
import numpy as np
from neuron import h

from PySONIC.postpro import findPeaks
from PySONIC.constants import *
from PySONIC.utils import si_format


def getNmodlDir():
    ''' Return path to directory containing MOD files and compiled mechanisms files. '''
    selfdir = os.path.dirname(os.path.realpath(__file__))
    return os.path.join(selfdir, 'nmodl')


def sennGeometry(fiberD=20.):
    ''' Return SENN model geometrical parameters for a given fiber diameter. '''
    nodeD = 0.7 * fiberD  # um
    nodeL = 2.5  # um
    interD = fiberD  # um
    interL = 100 * fiberD  # um
    return [nodeD, nodeL, interD, interL]


def VextPointSource(I, r, rho=300.0):
    ''' Compute the extracellular electric potential generated by a given point-current source
        at a given distance in a homogenous, isotropic medium.

        :param I: stimulation current amplitude (uA)
        :param r: euclidian distance(s) between the source and the point(s) of interest (um)
        :param rho: extracellular medium resistivity (Ohm.cm)
        :return: computed extracellular potential(s) (mV)
    '''
    return rho * I / (4 * np.pi * r) * 1e1  # mV


def getSpikesTimings(t, Vm_traces, tstart=None, tend=None):
    ''' Return an array containing occurence times of spikes detected on a collection of nodes.

        :param t: time vector (s)
        :param Vm_traces: vector of membrane potential traces
        :param tstart (optional): starting time for spike detection (s)
        :param tend (optional): end time for spike detection (s)
        :return: nnodes x nspikes 2D matrix with occurence time (ms) per node and spike.
    '''

    # Discard start or end of traces if needed
    if tstart is not None:
        Vm_traces = [Vm[t >= tstart] for Vm in Vm_traces]
        t = t[t >= tstart]
    if tend is not None:
        Vm_traces = [Vm[t <= tend] for Vm in Vm_traces]
        t = t[t <= tend]

    dt = (t[1] - t[0]) * 1e3  # s
    mpd = int(np.ceil(SPIKE_MIN_DT / dt))
    nspikes = None
    tspikes = []
    for Vm in Vm_traces:

        # Detect spikes on current trace
        ispikes, *_ = findPeaks(Vm, SPIKE_MIN_VAMP, mpd, SPIKE_MIN_VPROM)

        # Assert consistency of spikes propagation
        if nspikes is None:
            nspikes = ispikes.size
            if nspikes == 0:
                print('Warning: no spikes detected')
                return None
        else:
            assert ispikes.size == nspikes, 'Inconsistent number of spikes in different nodes'

        # Consider spikes as time of zero-crossing preceding each peak
        i_zcross = np.where(np.diff(np.sign(Vm)) > 0)[0]  # detect ascending zero-crossings
        slopes = (Vm[i_zcross + 1] - Vm[i_zcross]) / (t[i_zcross + 1] - t[i_zcross])  # slopes
        offsets = Vm[i_zcross] - slopes * t[i_zcross]  # offsets
        tzcross = -offsets / slopes  # interpolated times
        tspikes.append(tzcross)

    return np.array(tspikes) * 1e3


def getConductionSpeeds(xcoords, tspikes):
    ''' Compute average conduction speed from simulation results.

        :param xcoords: vector of node longitudinal coordinates (um)
        :param tspikes: nnodes x nspikes 2D matrix with occurence time (ms) per node and spike.
        :return: (nnodes - 1) x nspikesconduction speed matrix (m/s).
    '''
    nnodes, nspikes = tspikes.shape
    dists = np.diff(xcoords)  # internodal distances (um)
    delays = np.abs(np.diff(tspikes, axis=0))  # node-to-node delays (ms)
    return (dists / delays.T).T * 1e-3  # node-to-node conduction velocities (m/s)


class IPulse:
    ''' This uses NEURON's event delivery system to control the current supplied by an IClamp.
        A similar strategy can be used to drive discontinuous changes in any other parameter.
        1.  During simulation initialization, the stimulus current is set to 0, and an
        FInitializeHandler is used to launch an event that will arrive at the time when we want the
        first jump of stim.amp to occur.
        2.  Arrival of this event causes proc toggleStim() to be called.
        3.  toggleStim() assigns a new value to stim.amp, and uses the CVode class's event() method to
        launch two new events.  The first of these will come back in the future to turn off the
        stimulus. The second will come back a bit later, to turn it back on again, and start a new
        cycle.
    '''

    def __init__(self, sec, dur, amp, start, interval):

        self.dur = dur  # ms, duration of each pulse
        self.amp = amp  # nA
        self.start = start  # ms, time of first pulse
        self.interval = interval  # ms, interval between pulses (from pulse end to the start of the next one)

        self.stimon = 0
        self.stim = h.IClamp(sec(0.5))

        self.fih = h.FInitializeHandler(self.initialize)
        self.cvode = h.CVode()

        self.initialize()

    def initialize(self):
        self.stimon = 0
        self.stim.amp = 0  # prevent value at end of a run from contaminating the start of the following run
        self.stim.delay = 0  # we want to exert control over amp starting at 0 ms
        self.stim.dur = 1e9  # if we're going to change amp, dur must be long enough to span all our changes
        self.cvode.event(start, self.toggleStim)
        print("launched event that will turn on pulse at ", self.start)

    def toggleStim(self):
        print("t = ", h.t)
        if (self.stimon == 0):
            self.stimon = 1
            self.stim.amp = self.amp
            self.cvode.event(h.t + self.dur, self.toggleStim)
            print("stim.amp = ", self.stim.amp, ", launched event to turn pulse off")
        else:
            self.stimon = 0
            self.stim.amp = 0
            self.cvode.event(h.t + self.interval, self.toggleStim)
            print("stim.amp = ", self.stim.amp, ", launched event to turn next pulse on")

        # we've changed a parameter abruptly so we really should re-initialize cvode
        if self.cvode.active():
            self.cvode.re_init()
        else:
            h.fcurrent()


if __name__ == '__main__':
    dur = 0.1  # ms, duration of each pulse
    amp = 0.1  # nA
    start = 5  # ms, time of first pulse
    interval = 25  # ms, interval between pulses (from pulse end to the start of the next one)

    sec = h.Section(name='section')
    ipulse = IPulse(sec, dur, amp, start, interval)
