# -*- coding: utf-8 -*-
# @Author: Theo Lemaire
# @Email: theo.lemaire@epfl.ch
# @Date:   2019-08-23 09:43:18
# @Last Modified by:   Theo Lemaire
# @Last Modified time: 2019-08-26 11:56:56

import abc
import numpy as np

from PySONIC.utils import si_format


class PointSource(metaclass=abc.ABCMeta):

    @property
    @abc.abstractmethod
    def modality(self):
        ''' Keyword used to characterize stimulation modality. '''
        raise NotImplementedError

    def __init__(self, x, z):
        self.x = x
        self.z = z

    def __repr__(self):
        return f'{self.__class__.__name__}(x = {si_format(self.x)}m, z = {si_format(self.z)}m)'

    def strAmp(self, amp):
        return '{} = {}{}'.format(
            self.modality['name'],
            si_format(amp * self.modality.get('factor', 1.), precision=2),
            self.modality['unit']
        )

    def distance(self, x, z):
        return np.sqrt((x - self.x)**2 + (z - self.z)**2)

    @property
    @abc.abstractmethod
    def computeDistributedAmps(self, amp, fiber):
        return NotImplementedError

    @property
    @abc.abstractmethod
    def reverseComputeAmp(self):
        return NotImplementedError


class CurrentPointSource(PointSource):

    modality = {'name': 'I', 'unit': 'A'}

    def __init__(self, x, z, mode='cathode', rho=300.0):
        self.rho = rho
        if mode == 'cathode':
            self.is_cathodal = True
        elif mode == 'anode':
            self.is_cathodal = False
        else:
            raise ValueError(f'Unknown polarity: {mode} (should be "cathode" or "anode")')
        super().__init__(x, z)

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        keys = ['x', 'z', 'rho', 'is_cathodal']
        return sum([getattr(self, k) != getattr(other, k) for k in keys]) == 0

    def Vext(self, I, r):
        ''' Compute the extracellular electric potential generated by a given point-current source
            at a given distance in a homogenous, isotropic medium.

            :param I: point-source current amplitude (A)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :param rho: extracellular medium resistivity (Ohm.cm)
            :return: extracellular potential(s) (mV)
        '''
        return self.rho * I / (4 * np.pi * r) * 1e1  # mV

    def Iext(self, V, r):
        ''' Compute the point-current source amplitude that generates a given extracellular
            electric potential at a given distance in a homogenous, isotropic medium.

            :param V: electric potential (mV)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :param rho: extracellular medium resistivity (Ohm.cm)
            :return: point-source current amplitude (A)
        '''
        return 4 * np.pi * r * V / self.rho * 1e-1  # mV

    def computeDistributedAmps(self, I, fiber):
        ''' Compute extracellular potential value at all fiber nodes. '''
        distances = self.distance(fiber.getNodeCoords(), 0.)  # m
        return self.Vext(I, distances)  # mV

    def reverseComputeAmp(self, fiber, Ve):
        # Compute distance of closest node to point-source
        rmin = min(self.distance(fiber.getNodeCoords(), 0.))  # m

        # Compute the current needed to generate the extracellular potential value at this node
        return self.Iext(Ve, rmin)  # A

    def isCathodal(self, amp):
        return amp <= 0

    def chronaxie(self, durations, Ithrs):
        ''' Return chronaxie, i.e. stimulus duration for which threshold current is twice the rheobase. '''
        if self.is_cathodal:
            Ithrs = -Ithrs
        Irh = 2 * Ithrs.min()  # rheobase current
        return np.interp(Irh, Ithrs[::-1], durations[::-1])  # s
