# -*- coding: utf-8 -*-
# @Author: Theo Lemaire
# @Email: theo.lemaire@epfl.ch
# @Date:   2019-08-23 09:43:18
# @Last Modified by:   Theo Lemaire
# @Last Modified time: 2019-09-22 16:57:45

import abc
import numpy as np

from PySONIC.utils import si_format, rotAroundPoint2D


class PointSource(metaclass=abc.ABCMeta):

    @property
    @abc.abstractmethod
    def modality(self):
        ''' Keyword used to characterize stimulation modality. '''
        raise NotImplementedError

    # @property
    # @abc.abstractmethod
    # def attrkeys(self):
    #     ''' attributes to compare for object equality assessment. '''
    #     raise NotImplementedError

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return sum([getattr(self, k) != getattr(other, k) for k in self.attrkeys]) == 0

    def strAmp(self, amp):
        return '{} = {}{}'.format(
            self.modality['name'],
            si_format(amp * self.modality.get('factor', 1.), precision=2),
            self.modality['unit']
        )

    @property
    @abc.abstractmethod
    def computeNodesAmps(self, fiber, A):
        return NotImplementedError

    @property
    @abc.abstractmethod
    def computeSourceAmp(self, fiber, A):
        return NotImplementedError


class IntracellularPointSource(PointSource):

    def __init__(self, inode):
        self.inode = inode
        self.attrkeys = ['inode']

    def __repr__(self):
        return f'{self.__class__.__name__}(inode = {self.inode})'

    def computeNodesAmps(self, fiber, A):
        amps = np.zeros(fiber.nnodes)
        amps[self.inode] = A
        return amps

    def computeSourceAmp(self, fiber, A):
        return A


class ExtracellularPointSource(PointSource):

    def __init__(self, x, z):
        self.x = x
        self.z = z
        self.attrkeys = ['x', 'z']

    def __repr__(self):
        return f'{self.__class__.__name__}(x = {si_format(self.x)}m, z = {si_format(self.z)}m)'

    def distance(self, x, z):
        return np.sqrt((x - self.x)**2 + (z - self.z)**2)


class CurrentPointSource(PointSource):

    modality = {'name': 'I', 'unit': 'A'}

    def __init__(self, mode):
        if mode == 'cathode':
            self.is_cathodal = True
        elif mode == 'anode':
            self.is_cathodal = False
        else:
            raise ValueError(f'Unknown polarity: {mode} (should be "cathode" or "anode")')
        self.attrkeys.append('is_cathodal')

    def isCathodal(self, amp):
        return amp <= 0


class ExtracellularCurrent(ExtracellularPointSource, CurrentPointSource):

    def __init__(self, x, z, mode='cathode', rho=300.0):
        ''' Initialization.

            :param rho: extracellular medium resistivity (Ohm.cm)
        '''
        self.rho = rho
        ExtracellularPointSource.__init__(self, x, z)
        CurrentPointSource.__init__(self, mode)
        self.attrkeys.append('rho')

    def Vext(self, I, r):
        ''' Compute the extracellular electric potential generated by a given point-current source
            at a given distance in a homogenous, isotropic medium.

            :param I: point-source current amplitude (A)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :return: extracellular potential(s) (mV)
        '''
        return self.rho * I / (4 * np.pi * r) * 1e1  # mV

    def Iext(self, V, r):
        ''' Compute the point-current source amplitude that generates a given extracellular
            electric potential at a given distance in a homogenous, isotropic medium.

            :param V: electric potential (mV)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :return: point-source current amplitude (A)
        '''
        return 4 * np.pi * r * V / self.rho * 1e-1  # mV

    def computeNodesAmps(self, fiber, I):
        ''' Compute extracellular potential value at all fiber nodes. '''
        distances = self.distance(fiber.getNodeCoords(), 0.)  # m
        return self.Vext(I, distances)  # mV

    def computeSourceAmp(self, fiber, Ve):
        # Compute distance of closest node to point-source
        rmin = min(self.distance(fiber.getNodeCoords(), 0.))  # m

        # Compute the current needed to generate the extracellular potential value at this node
        return self.Iext(Ve, rmin)  # A

    def filecodes(self, A):
        return {
            'psource': f'ps({(self.x * 1e3):.1f},{(self.z * 1e3):.1f})mm',
            'A': f'{(A * 1e3):.2f}mA'
        }


class IntracellularCurrent(IntracellularPointSource, CurrentPointSource):

    conv_factor = 1e9  # A to nA

    def __init__(self, inode, mode='anode'):
        IntracellularPointSource.__init__(self, inode)
        CurrentPointSource.__init__(self, mode)

    def computeNodesAmps(self, fiber, A):
        return IntracellularPointSource.computeNodesAmps(self, fiber, A) * self.conv_factor

    def filecodes(self, A):
        return {
            'psource': f'ps(node{self.inode})',
            'A': f'{(A * self.conv_factor):.2f}nA'
        }


class AcousticPointSource(PointSource):

    modality = {'name': 'A', 'unit': 'Pa'}
    conv_factor = 1e-3  # Pa to kPa

    def __init__(self, Fdrive):
        self.Fdrive = Fdrive  # Hz

    def filecodes(self, A):
        return {
            'f': f'{self.Fdrive * 1e-3:.0f}kHz',
            'A': f'{(A * self.conv_factor):.2f}kPa'
        }


class NodeAcousticSource(IntracellularPointSource, AcousticPointSource):

    def __init__(self, inode, Fdrive):
        IntracellularPointSource.__init__(self, inode)
        AcousticPointSource.__init__(self, Fdrive)

    def __repr__(self):
        return f'{IntracellularPointSource.__repr__(self)[:-1]}, {self.Fdrive * 1e-3:.0f} kHz)'

    def computeNodesAmps(self, fiber, A):
        return IntracellularPointSource.computeNodesAmps(self, fiber, A) * self.conv_factor

    def filecodes(self, A):
        return {**{'psource': f'ps(node{self.inode})'}, **super().filecodes(A)}


class PlanarDiskTransducerAcousticSource(ExtracellularPointSource, AcousticPointSource):
    ''' Acoustic source coming from a distant disk planar transducer.
        For now, acoustic propagation is only computed along the transducer normal axis.
        The rest of the field is computed assuming radial symmetry.
    '''

    def __init__(self, x, z, Fdrive, rho=1204.1, c=1515.0, theta=0, zf=0, r=2e-3):
        ''' Initialization.

            :param rho: medium density (kg/m3)
            :param c: medium speed of sound (m/s)
            :param theta: transducer angle of incidence (radians)
            :param zf: fiber initial location (m)
            :param r: transducer radius (m)
        '''
        ExtracellularPointSource.__init__(self, x, z)
        AcousticPointSource.__init__(self, Fdrive)
        self.rho = rho
        self.c = c
        self.zf = zf
        self.theta = theta
        self.r = r
        for k in ['rho', 'c', 'theta', 'r']:
            self.attrkeys.append(k)

        # Angular wave number
        self.kf = 2 * np.pi * self.Fdrive / self.c

    def normalAxisAmp(self, z, u):
        ''' Compute the acoustic amplitude at a given distance along the transducer normal axis.

            :param z: distance from transducer (m)
            :param u: particle velocity normal to the transducer surface.
            :return: acoustic amplitude (Pa)
        '''
        j = complex(0, 1)  # imaginary number
        ez = np.exp(j * self.kf * z)
        ezr = np.exp(j * self.kf * np.sqrt(z**2 + self.r**2))
        return self.rho * self.c * u * (ez - ezr)

    def computeNodesAmps(self, fiber, u):
        ''' Compute acoustic amplitude value at all fiber nodes, given
            a transducer normal particle velocity.

            :param fiber: fiber model object
            :param u: particle velocity normal to the transducer surface.
            :return: vector of acoustic amplitude at the nodes (Pa)
         '''

        # Get fiber nodes coordinates
        node_coords = np.array([fiber.getNodeCoords(), np.zeros(fiber.nnodes)])

        # Rotate around source incident angle
        node_coords = rotAroundPoint2D(node_coords, self.theta, (self.x, self.z))

        # Compute amplitudes assuming radial symmetry (i.e. as if every point was along the normal axis)
        amps = self.normalAxisAmp(self.distance(*node_coords), u)

        # Return magnitude of complex vector, converted to appropriate scale
        return np.abs(amps) * self.conv_factor  # kPa

    def computeSourceAmp(self, fiber, A):
        return NotImplementedError

    def filecodes(self, u):
        return {
            'psource': f'ps({(self.x * 1e3):.1f},{(self.z * 1e3):.1f})mm',
            'f': f'{self.Fdrive * 1e-3:.0f}kHz',
            'u': f'{si_format(u, 2)}m/s'
        }
