# -*- coding: utf-8 -*-
# @Author: Theo Lemaire
# @Email: theo.lemaire@epfl.ch
# @Date:   2019-08-23 09:43:18
# @Last Modified by:   Theo Lemaire
# @Last Modified time: 2019-08-30 10:47:20

import abc
import numpy as np

from PySONIC.utils import si_format


class PointSource(metaclass=abc.ABCMeta):

    @property
    @abc.abstractmethod
    def modality(self):
        ''' Keyword used to characterize stimulation modality. '''
        raise NotImplementedError

    # @property
    # @abc.abstractmethod
    # def attrkeys(self):
    #     ''' attributes to compare for object equality assessment. '''
    #     raise NotImplementedError

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return NotImplemented
        return sum([getattr(self, k) != getattr(other, k) for k in self.attrkeys]) == 0

    def strAmp(self, amp):
        return '{} = {}{}'.format(
            self.modality['name'],
            si_format(amp * self.modality.get('factor', 1.), precision=2),
            self.modality['unit']
        )

    @property
    @abc.abstractmethod
    def computeNodesAmps(self, fiber, A):
        return NotImplementedError

    @property
    @abc.abstractmethod
    def computeSourceAmp(self, fiber, A):
        return NotImplementedError


class IntracellularPointSource(PointSource):

    def __init__(self, inode):
        self.inode = inode
        self.attrkeys = ['inode']

    def __repr__(self):
        return f'{self.__class__.__name__}(inode = {self.inode})'

    def computeNodesAmps(self, fiber, A):
        amps = np.zeros(fiber.nnodes)
        amps[self.inode] = A
        return amps

    def computeSourceAmp(self, fiber, A):
        return A


class ExtracellularPointSource(PointSource):

    def __init__(self, x, z):
        self.x = x
        self.z = z
        self.attrkeys = ['x', 'z']

    def __repr__(self):
        return f'{self.__class__.__name__}(x = {si_format(self.x)}m, z = {si_format(self.z)}m)'

    def distance(self, x, z):
        return np.sqrt((x - self.x)**2 + (z - self.z)**2)


class CurrentPointSource(PointSource):

    modality = {'name': 'I', 'unit': 'A'}

    def __init__(self, mode):
        if mode == 'cathode':
            self.is_cathodal = True
        elif mode == 'anode':
            self.is_cathodal = False
        else:
            raise ValueError(f'Unknown polarity: {mode} (should be "cathode" or "anode")')
        self.attrkeys.append('is_cathodal')

    def isCathodal(self, amp):
        return amp <= 0


class ExtracellularCurrent(ExtracellularPointSource, CurrentPointSource):

    def __init__(self, x, z, mode='cathode', rho=300.0):
        self.rho = rho
        ExtracellularPointSource.__init__(self, x, z)
        CurrentPointSource.__init__(self, mode)
        self.attrkeys.append('rho')

    def Vext(self, I, r):
        ''' Compute the extracellular electric potential generated by a given point-current source
            at a given distance in a homogenous, isotropic medium.

            :param I: point-source current amplitude (A)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :param rho: extracellular medium resistivity (Ohm.cm)
            :return: extracellular potential(s) (mV)
        '''
        return self.rho * I / (4 * np.pi * r) * 1e1  # mV

    def Iext(self, V, r):
        ''' Compute the point-current source amplitude that generates a given extracellular
            electric potential at a given distance in a homogenous, isotropic medium.

            :param V: electric potential (mV)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :param rho: extracellular medium resistivity (Ohm.cm)
            :return: point-source current amplitude (A)
        '''
        return 4 * np.pi * r * V / self.rho * 1e-1  # mV

    def computeNodesAmps(self, fiber, I):
        ''' Compute extracellular potential value at all fiber nodes. '''
        distances = self.distance(fiber.getNodeCoords(), 0.)  # m
        return self.Vext(I, distances)  # mV

    def computeSourceAmp(self, fiber, Ve):
        # Compute distance of closest node to point-source
        rmin = min(self.distance(fiber.getNodeCoords(), 0.))  # m

        # Compute the current needed to generate the extracellular potential value at this node
        return self.Iext(Ve, rmin)  # A

    def filecodes(self, A):
        return {
            'psource': f'ps({(self.x * 1e3):.1f},{(self.z * 1e3):.1f})mm',
            'A': f'{(A * 1e3):.2f}mA'
        }


class IntracellularCurrent(IntracellularPointSource, CurrentPointSource):

    conv_factor = 1e9  # A to nA

    def __init__(self, inode, mode='anode'):
        IntracellularPointSource.__init__(self, inode)
        CurrentPointSource.__init__(self, mode)

    def computeNodesAmps(self, fiber, A):
        return IntracellularPointSource.computeNodesAmps(self, fiber, A) * self.conv_factor

    def filecodes(self, A):
        return {
            'psource': f'ps(node{self.inode})',
            'A': f'{(A * self.conv_factor):.2f}nA'
        }


class AcousticPointSource(PointSource):

    modality = {'name': 'A', 'unit': 'Pa'}

    def __init__(self):
        pass


class IntracellularUS(IntracellularPointSource, AcousticPointSource):

    conv_factor = 1e-3  # Pa to kPa

    def __init__(self, inode):
        IntracellularPointSource.__init__(self, inode)
        AcousticPointSource.__init__(self)

    def computeNodesAmps(self, fiber, A):
        return IntracellularPointSource.computeNodesAmps(self, fiber, A) * self.conv_factor

    def filecodes(self, A):
        return {
            'psource': f'ps(node{self.inode})',
            'A': f'{(A * self.conv_factor):.2f}kPa'
        }


class ExtracellularUS(ExtracellularPointSource, AcousticPointSource):

    def __init__(self, x, z, rho=..., c=...):
        ''' Initialization.

            :param rho: medium density (kg/m3)
            :param c: medium speed of sound (m/s)
        '''
        self.rho = rho
        self.c = c
        ExtracellularPointSource.__init__(self, x, z)
        AcousticPointSource.__init__(self)
        self.attrkeys.append('rho', 'c')

    def Atarget(self, Asource, r):
        ''' Compute the target acoustic amplitude generated by a given point-acoustic source
            at a given distance in a homogenous, isotropic medium.

            :param Asource: point-source acoustic amplitude (Pa)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :param rho: extracellular medium density (kg/m3)
            :return: target acoustic amplitude(s) (Pa)
        '''
        return ...  # Pa

    def Asource(self, Atarget, r):
        ''' Compute the point-acoustic source amplitude that generates a given extracellular
            aoucstic amplitude at a given distance in a homogenous, isotropic medium.

            :param Atarget: target acoustic amplitude (Pa)
            :param r: euclidian distance(s) between the source and the point(s) of interest (m)
            :param rho: extracellular medium density (kg/m3)
            :return: point-source acoustic amplitude (Pa)
        '''
        return ...  # Pa

    def computeNodesAmps(self, fiber, A):
        ''' Compute acoustic amplitude value at all fiber nodes. '''
        distances = self.distance(fiber.getNodeCoords(), 0.)  # m
        return self.Atarget(A, distances)  # Pa

    def computeSourceAmp(self, fiber, A):
        # Compute distance of closest node to point-source
        rmin = min(self.distance(fiber.getNodeCoords(), 0.))  # m

        # Compute the source amplitude needed to generate the acoustic amplitude value at this node
        return self.Asource(A, rmin)  # Pa

    def filecodes(self, A):
        return {
            'psource': f'ps({(self.x * 1e3):.1f},{(self.z * 1e3):.1f})mm',
            'A': f'{(A * self.conv_factor):.2f}kPa'
        }
